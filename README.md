[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15545715&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.<br>
Software engineering is an approach taken in the production of software from the early stages to the final stages and through the maintenance process. The engineering process includes taking into account the system and user requirements, the practical cost, development schedule, development and maintenance of the software. The software engineering process has various implementation strategies depending on the software being created and the model used for the specific software. The engineering process provides emphasis on the dependability of the software required and the quality of the software developed.<br>
Software engineering plays a vital role in the technology industry. The approach taken by engineers in the creation of software has helped in the development of key systems that have been the pillars of change. Continuous advancement in the development process has led to the creation of simpler and cheaper software which are easy to maintain and more scalable. The engineering process provides a clear guideline for engineers to use and create software preventing the creation of complex and unmaintainable software.  The technological industry has grown impacting other economical sectors, and these changes are attributed to the advancements noted in the software engineering process.<br>

Identify and describe at least three key milestones in the evolution of software engineering.<br>
The formal conferment of the term software engineering, It recognized software development as an engineering discipline and not as an art as it was previously identified. The formal introduction of the engineering state brought forth a more structured approach to software development where formal standards of design were created to impact the development process.<br>
The introduction of object oriented programming in the 1980s was key to the shift in the development process. Along side OOP came the introduction of agile software development methodologies which enhanced flexibility within the field and made is easy to improve and maintain software post-release. <br>
The use of micro-services architecture from monolithic brought forth change in the development field.  Software were built as services which were given specific functionalities. This approach came with automation and continuous integrations of systems and the DevOps culture as well as the Cloud revolution. <br>

List and briefly explain the phases of the Software Development Life Cycle.<br>
Planning - The planning stage provides an overall structure of the development process, it defines the software purpose and plots the best approach for the creation of the software. It includes taking a feasibility study to help understand the target users and the business aspect and its relevance to the business.<br>
Requirement Analysis - The requirement phase  involves coming up with the functional, operational, and design requirements of the software in question. These requirements are based on what the user requires the software to do. All the requirements are documented and in detail and act as a guideline for the development process.<br>
Design- The architectural phase includes coming up with the design phase of the software to be developed. It will include coming up with components and interfaces and the relations between these components. A detailed phase provides an overall detail for the software in development. <br>
Coding- This phase is the stage at which developers get to work. It involves translating the design of the software into tangible code. Furthermore, code reviews are conducted in this phase of development.<br>
Testing - The testing phase is the stage at which the code is tested to check if it works appropriately. It is also identified as the debugging process. The testing process can include unit testing and integration testing. It checks on the vulnerabilities of the software and identifies the different software conditions of the software.<br>
Deployment - after the programming aspect, the software is presented to the end users. At this juncture, the product is well tested and is released in such a way that ensures user experience is not affected and users are trained to operate it with ease.<br>
Maintenance - The maintenance includes frequent updates, constant security checks to ensure the functionality of the software is standard and quality. The focus of this phase is to ensure the software adapt to the ever changing needs of the user and the environment. <br>

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.<br>
The waterfall and agile development methodologies are two of the most prominent in the development field. They are quite distinct and understanding them provides a clear understanding on how best to approach the development process. <br>
Agile methodology is an iterative process which promotes flexibility in the development process. Through this methodology, collaboration is encouraged across the teams with changes made to the program based on the improvements structured in during development. Furthermore, the process relies on continuous feedback and small but constant releases. Through the methodology, there is a fast time advancement in development and issues are tackled at an earlier stage hence preventing constant improvements immediately after release.<br>
The Waterfall methodology is a rigid process with distinct phases that are required to be followed. The methodology follows a predestined path in which the earlier stages are concentrated on. Each phase within this methodology must be completed before moving on to the next and it does not encourage going back and forth on the phases. This development model provides a clear pathway for developers to use for project execution. Furthermore, it provides a predictable and stable path for development. Predictability is noted within the budgets set and the project timelines which dictate the development and implementation process. However, the methodology might prove to costly when it requires updates as the development costs will increase exponentially.<br>

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.<br>
Software Developer - In a software engineering team, the software developer’s main job is to capture the requirements presented by the user, working on the software design, the development process which includes coding, testing and maintenance  of the software. The development process includes identifying the right methodologies to use, languages they will use in the coding process, and different tests that will be utilized to check the validity of the software. Once the development process is done, the software developer is required to regularly update and improve the software. <br>
Quality Assurance Engineer - A quality assurance engineer has the sole mandate of ensuring that the quality of the product is up to par. They ensure that all requirements noted in the requirement stage are met. Additionally, the quality of the software is determined based on the tests done  and the implementation of the  program source code. The quality assurance engineer is responsible for anticipating problems during the development stage and resolving them entirely. Implementation of the quality assurance plan ensures that the quality of the product is met and provides a report for the management. <br>
Project Manager - A project manager plays a key role in the project planning, implementation, and completion. The main tasks of the project manager are project planning and project monitoring and control. The project planning phase includes writing the project proposal, doing project cost estimations, project scheduling and staffing process. During implementation, the project manager is responsible for tailoring the software process, monitoring the design process, programming, testing and control configuration management. Further, they look into risks and how they can be managed, report writing during and after the project, project presentation, and client handling.<br>

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.<br>
Integrated Development Environments(IDEs) are necessary as they enable the developer work more efficiently while building software. IDEs have various features that enable the building, testing and packaging of the software in an easy manner. They are important because are at the center of the development process and make it more efficient. Further, they make it easier by providing an environment that is easily adaptable to the various programming languages. Other advantages of IDEs are intelligent code completion, local build automation, syntax highlighting, compilation, testing, and code editing automation. Examples of IDEs include AWS Cloud9 and Visual Studio Code.<br>
Version Control Systems are programs with the capability of tracking every alteration made to a file while it is still under development. The systems enable developers to track changes to the programs, update the programs while keeping previous files, and roll back programs to their previous versions. The systems mandate is to protect the source code from damage and provide developers with room to explore and experiment with their code. Additionally, it provides room for collaboration between developers and helps them track changes based on who committed them and how they affect the system in development. Other advantages of version control systems include improving the quality of the product, accelerating development, and provide visibility for the program. Examples of VCS are Git and Mercurial.<br>

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.<br>
Software engineers are expected to cope with the ever increasing changes in the field. The software engineering field is constantly evolving hence the need for engineers to update their knowledge to stay up to par with the rest of the field. Therefore, there is need for a standardized way of implementing changes, because when they are unstandardized that is when engineers find themselves overwhelmed by all the changes implemented.<br>
Development of quality and trustworthy systems with strong security. With increased cases of cyber crimes, developers have a challenge to create systems and software with no exploitable vulnerabilities. All stakeholders within the software engineering process need to take charge of cyber security. Developers need to look at creation with high level programming languages and improve the security of the software.<br>
Maintaining software quality despite short time frameworks. The quality of the software is determined by ensuring that code is reviewed and errors noted corrected. However, due to time constraints developers tend to ignore errors and suppress. At other times, the code does not go through review hence problems will crop up at a later time. The best way to overcome this problem is to follow the quality assurance process after the coding of the software<br>

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.<br>
Unit testing- Unit testing is an isolated form of testing dedicated to  class or function. The specific component is isolated and tested to see its performance. It is a fast-paced testing system which looks to ensure the working of each unit in the system. With this mode of testing, units are tested when without side effects and if there are any mocking is done to ensure smooth testing.<br>
Integration testing - While unit testing considers specific units, integration testing takes into account the entire system and the inner workings of the software. The testing system looks at the entire implementation phase and raises issues affecting the application parts. The testing is done during the final stages of implementation to check on the quality of the system.<br>
System testing - System testing is an error finding test that looks into the different components  of the system, their interaction, and errors that arise from these interactions. The test further looks into the functional and non-functional requirements of the system and checks to see if the various components meet the requirements noted.<br>
Acceptance testing - This testing is usual done during the final stages of software development. It is done to check whether the system or software is ready for the market. Acceptance testing uses real data to check if the software meets the requirements in the specification’s stage. It reveals errors based on customer data provided to check the operation-ability of the software.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.<br>
Prompt engineering is the concept of coming up with the best statements to feed to AI models to get the best responses. Prompt engineering works with various aspects of AI use including content generation tools like ChatGPT and chatbots. This concept is important in the interaction of human beings with AI as it provides a clear and concise method of asking questions. Prompt engineering provides a clear guideline on how to get the most direct questions. While interacting with AI models people need to provide clear unambiguous instructions to ensure they get the best results.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.<br>
Vague prompt: How to fix a computer? <br>
Improved prompt: How can I fix a HP 402 that gives the error 49 code?<br>
The first prompt is a vague prompt that asks to fix the computer and therefore the AI will have no idea what problem needs to be fixed hence the response will be just as ambiguous. On the other hand, the improved prompt provides the computer model and the issue that needs to be fixed hence it will be much easier for the AI model to provide clear instructions on how to fix the error code on the brand mentioned in the prompt. The prompt is clear and precise making it easy for the AI to give clear responses as well.
